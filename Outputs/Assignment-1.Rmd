---
title: "Understanding Toronto and its Neighbourhoods Through Homicide Rates"
author: "Cindy Ly"
date: "31/01/2022"
output: pdf_document
abstract: "[Insert Here]"
bibliography: [references.bib, literature.bib]
---

\tableofcontents
\pagebreak

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
options(repos = list(CRAN="http://cran.rstudio.com/"))
install.packages("opendatatoronto")
install.packages("dplyr")
install.packages("tidyverse")
install.packages("janitor")
install.packages("tidyr")
install.packages("bibtex")
```

## 1. Introduction


```{r introduction}
```

## 2. Data


### 2.1. Data Source & Implications

The data used in this paper was taken from Toronto Open Data, a catalogue of datasets created by the City of Toronto to increase transparency and encourage data literacy. This open data allows communities to engage in political conversations and raise awareness to policymakers and other residents. The dataset I used was the Toronto Police's Annual Statistical Report on Homicides. The raw data includes homicides form 2004 to 2020 in each neighbourhood and includes homicide type. This includes shooting, stabbing, and other. The data also includes geo-spatial data that can be used to pin point specific homicide locations on a map. However, to protect the privacy of parties, the pin points are moved to the nearest intersection [@TorontoOpenData]. As a result, homicide numbers by division or neighbourhood may be inaccurate as the exact number of homicides within geographical boundaries are not reflected [@TorontoOpenData]. This means there is a possibility that this data could be biased depending on how much or little the Police offset case locations.

There are ethical implications to consider with this data. There is some ambiguity on what is considered a homicide case. The Toronto Police Open Data Documentation says that offences include first degree murder, second degree murder, and manslaughter. It also states, "Deaths caused by criminal negligence, suicide, or accidental or justifiable homicide (i.e self-defence) are not included." [@TorontoOpenData]. Since this information was provided by Toronto Police Services, it is subject to extreme bias. As seen with recent protests demanding more accountability from Police institutions worldwide, there is a great lack of transparency when it comes to police brutality and racism within the force. Therefore, it is important to ask whether homicide at the hands of the police are considered in this dataset, or if they would rule cases as 'self-defence' and exclude it.

Another factor that could influence the dataset is whether or not the courts have decided on a ruling for homicide cases. There are cases that could be ongoing or verdict-less. Therefore, the number of deaths from homicide could not be accurately represented per year if cases are still awaiting trial.

### 2.2. Methodology

```{r data cleanup, include=FALSE}
library(opendatatoronto)
library(dplyr)
library(janitor)
library(tidyverse)
library(tidyr)
 
## Police Annual Statistics Report - Homicide dataset was used for this paper
# get package from Toronto Open Data
package <- show_package("7d72bbbe-8adc-4b36-8ad1-5359f1c7a9cc")
 
# get all resources for this package
resources <- list_package_resources("7d72bbbe-8adc-4b36-8ad1-5359f1c7a9cc")
 
# identify datastore resources; by default, Toronto Open Data sets datastore resource format to CSV for non-geospatial and GeoJSON for geospatial resources
datastore_resources <- filter(resources, tolower(format) %in% c('csv', 'geojson'))
 
# load the first datastore resource as a sample
data <- filter(datastore_resources, row_number()==1) %>% get_resource()

# basic cleaning of homicide dataset from janitor package
cleaned_homicide <-
  clean_names(data)
```


```{r data, include=FALSE}

## we want to look at the data from 2013-2020 and must select these rows

# the occurrence_year data is an integer, so we must convert to numeric before filtering
cleaned_homicide$occurrence_year <- as.numeric(cleaned_homicide$occurrence_year)

# we can filter the years out and create a new data frame
homicide_data <- subset(cleaned_homicide, cleaned_homicide$occurrence_year > 2012)

# lets create a table that includes homicide type and year
tab1 <- table(homicide_data$occurrence_year, homicide_data$homicide_type)

## now lets create a new column that will show us the total homicides that year

# we need to turn this into a dataframe first
tab1 <- as.data.frame.matrix(tab1) 

# now we can create a new column that will show us the total per neighbourhood
tab1 <-
  tab1 |>
  mutate(Total = Other + Shooting + Stabbing)
```

### 2.3. Homicide Types & Rates


```{r table, echo=FALSE}

# using knitr, we can make a nicer looking table for our markdown of homicide types
kable1 <-
  knitr::kable(
  tab1,
  "pipe",
  col.names = c("Other", "Shooting", "Stabbing", "Total"),
  align = "lccr",
  caption = "Number of Homicides by Type in Toronto from 2013 to 2020"
)

kable1
```

```{r graph, echo=FALSE}

graph1 <-
  (homicide_data |> 
  ggplot(mapping = aes(x = occurrence_year, fill = homicide_type)) +
  geom_bar(width = 0.7) +
  geom_text(stat='count', aes(label=..count..), position = position_stack(vjust = 0.5)) +
  labs(title = "Annual Homicide Type Count in Toronto from 2013 to 2020", 
       x = "Year", 
       y = "Cases",
       fill = "Homicide Type") +
  theme_minimal() +
  scale_fill_manual(values = c("#ffd675", "#4bc9a3", "#1c6fff"))
)

graph1
```

### 2.4. Neighbourhoods
```{r neighbourhood yearly, include=FALSE}
# lets look at the highest homicide count for the top 6 neighbourhoods from 2013 to 2020

# we need to create a table that counts homicide rate per year for each neighbourhood
# note: we use the table() rather than count() because there are "character" classes and not "numeric"
tab2 <- table(homicide_data$neighbourhood, homicide_data$occurrence_year)

# we need to turn this into a dataframe for easier processing
tab2 <- as.data.frame.matrix(tab2) 

# now we can create a new column that will show us the total per neighbourhood
tab2 <-
  tab2 |>
  mutate(Total = `2013` + `2014` + `2015` + `2016` + `2017` + `2018` + `2019` + `2020`)

# now we can use sort to order counts from smallest to greatest
sorted.tab2 <- tab2[order(as.numeric(tab2$Total)), ]
```


```{r neighbourhood table, echo=FALSE}
kable2 <- 
  knitr::kable(
  tail(sorted.tab2),
  "pipe",
  col.names = c("2013", "2014", "2015", "2016", "2017", "2018", "2019", "2020", "Total"),
  align = "lcccccccr",
  caption = "Greatest Homicide Counts in Toronto's Neighbourhoods from 2013 to 2020"
)

kable2
```

```{r neighbourhood rates, include=FALSE}
# now lets make a graph to show the total homicides between these years per neighbourhood
homicide_data$occurrence_year<-as.numeric(homicide_data$occurrence_year)

# lets start with a table 
tab3 <-
  count(homicide_data, neighbourhood)

# lets order this table from smallest to greatest while making the 'n' column numeric
sorted.tab3 <- tab3[order(as.numeric(tab3$n)), ]

# now lets find the 6 largest values (the last six in this data frame)
sorted.tab3 <- tail(sorted.tab3)
```


```{r neighbourhood graph, echo=FALSE, fig.height=6, fig.width=8}

# we can now graph all of these values 
graph2 <-
  sorted.tab3 |> 
    ggplot(mapping = aes(x = neighbourhood, y = n)) +
    geom_bar(stat = "identity", width = 0.7) +
    labs(title = "Toronto Neighbourhoods with the Greatest Homicide Cases from 2013 to 2020", 
        x = "Neighbourhood", 
        y = "Cases") +
    scale_x_discrete(labels = c("Waterfront Communities-The Island (77)" = "The Island", "West Humber-Clairville (1)" = "W. Humber Clairville", "Weston (113)" = "Weston", "Bay Street Corridor (76)" = "Bay St. Corridor", "Mount Olive-Silverstone-Jamestown (2)" = "Smithfield", "Moss Park (73)" = "Moss Park")) +
    geom_text(aes(label = n), vjust = -0.4) +
    theme_minimal()

graph2
```

## 3. Discussion

```{r citations, include=FALSE}
library(bibtex)

knitr::write_bib(c('knitr', 'opendatatoronto', 'tidyverse', 'ggplot2', 'dplyr', 'janitor', 'tidyr', 'bibtex'), file = 'references.bib')

Rcite = citation()
Rcite$key = "R"
bibtex::write.bib(Rcite, 'references.bib', append = TRUE)
 
```

# References
